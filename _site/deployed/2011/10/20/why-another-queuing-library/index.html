<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Why another queuing library?</title>
  <meta name="description" content="a blog about code">
  <meta name="author" content="Brandon Keepers">
  <meta name="verify-v1" content="UwU5mecrHiDTPVlphLl729aaRCmyz93jrs+ER3RP4Pw=">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google-site-verification" content="h4QNmQOrsvnIEsMH5GS3s4_jV3ZAZgrEoZdL4RsbOMI" />

  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" href="/assets/site-5735ecebbfb4d7db3bea8500ea53dae3.css">

  <link rel="openid.server" href="http://www.myopenid.com/server">
  <link rel="openid.delegate" href="http://bkeepers.myopenid.com/">
  <link href="http://feeds.feedburner.com/opensoul" rel="alternate" title="opensoul.org" type="application/atom+xml">

  <!-- FIXME:  -->
</head>
<body>
<div class="container">
  <header>
    <h1><a href="/">opensoul.org</a></h1>
  </header>

  <div id="content">
    <article>
  <h1 class="small">Why another queuing library?</h1>
  <p class="meta">
    <span class="date">October 20, 2011</span>
    <span class="tags">
      
        qu,
      
        ruby
      
    </span>
  </p>
  <div class="body"><p>Along with the release of <a href="http://speakerdeck.com">Speaker Deck</a>, we released <a href="https://github.com/bkeepers/qu">Qu</a>, a Ruby library for queuing and processing background jobs. Why another queuing library? I briefly explain why I wrote Qu in the <a href="https://github.com/bkeepers/qu#readme"><span class="caps">README</span></a>, so read that first. But I wanted to give a little more of the backstory.</p>
<h2>Reason #1: Resque issues on Heroku</h2>
<p>Speaker Deck makes heavy use of background processing to turn PDFs of slides into the gorgeous player that you see on the site. Speaker Deck was using Resque, but unfortunately there a few issues with Resque on Heroku (<a href="https://github.com/defunkt/resque/issues/368">#368</a>, <a href="https://github.com/defunkt/resque/issues/319">#319</a>). The mishandling of signals described in #368 was especially an issue for us,  because any time we deploy or scale the workers up or down, we would lose jobs; they wouldn&#8217;t show up as failed, they would just completely vanish.</p>
<p>So the logical approach would be to just fork resque, reverse the signals, and use that version, right? If that was my only issue with resque, then yes, but…</p>
<h2>Reason #2: Infrastructure dependencies</h2>
<p>At <a href="http://orderedlist.com">Ordered List</a>, all of our products are built on top of <a href="http://mongodb.org">MongoDB</a>. Both <a href="http://get.harmonyapp.com">Harmony</a> and <a href="http://get.gaug.es">Gaug.es</a> already have infrastructure set up to properly scale, replicate, and back up MongoDB. Both apps currently use resque minimally. Gaug.es literally only uses it to send email in the background since everything else is done in real-time. Harmony uses it slightly more.</p>
<p>So to run resque, we have to administer 4 additional Redis instances (master and slave in both production and staging) for both products. If we were at a scale where we needed Redis, the dependency would be warranted. But mongo is currently more than capable of doing what we need.</p>
<p>And I know we&#8217;re not alone. I&#8217;ve had many consulting clients in the past on shoe-string hosting budgets that didn&#8217;t need the robustness of Redis. delayed_job, were it more stable, was perfect for them.</p>
<h2>Reason #3: Cheap thrills</h2>
<p>Having been the primary maintainer of a <a href="https://github.com/collectiveidea/delayed_job">popular fork of delayed_job</a> for a couple years, I feel like I formed a lot of ideas about how I would build it differently. I made a lot of mistakes with delayed_job (let&#8217;s not talk about <span class="caps">YAML</span>), but I also learned a lot of lessons.</p>
<p>Supporting multiple backends is one of the most important things I think Qu can provide. Resque has a thriving ecosystem that is all built around Redis. As I said in Reason #2, Redis often makes sense, but there are times when it doesn&#8217;t. I find it extremely disappointing that the flourishing Resque ecosystem can&#8217;t be leveraged with another database backend. I think Qu can create an ecosystem with the benefit of being able to use it in every case.</p>
<p>One criticism of this approach is that databases have different features and strengths, so it will be impossible to make the backends behave the same. Each backend will certainly have it&#8217;s quirks, but fundamentally, I think they can all behave the same. The current Redis and Mongo backends are perfect examples of this. Internally, they both operate very differently, but their <span class="caps">API</span> is the same and they both pass the <a href="https://github.com/bkeepers/qu/blob/master/lib/qu/backend/spec.rb">same specs</a>.</p>
<p>So far, I&#8217;m very pleased with how Qu is turning out. There is still a lot of work to be done, but I think I have a good start and have been pleased by the intrest in it already.</p></div>

  <div id="be-social">
    <a href="https://twitter.com/share" class="twitter-share-button" data-via="bkeepers" data-lang="en" data-related="bkeepers">Tweet</a>
    <a href="https://twitter.com/bkeepers" class="twitter-follow-button" data-show-count="false" data-lang="en">Follow @bkeepers</a>
  </div>
</article>


<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  </div>

  <div id="about">
    <section>
      <p>I am <strong>Brandon Keepers</strong>. I build Internet things, usually with Ruby or JavaScript. I work at <a href="http://github.com">GitHub</a> and live in Holland, MI.</p>

      <ul id="links">
        <li>
          <a href="http://twitter.com/bkeepers">
            <span class="icon icon-mark-twitter"></span>
            Follow me on Twitter
          </a>
        </li>
        <li>
          <a href="http://github.com/bkeepers">
            <span class="icon icon-mark-github"></span>
            Follow me on GitHub
          </a>
        </li>
        <li>
          <a href="http://feeds.feedburner.com/opensoul">
            <span class="icon icon-feed"></span>
            Subscribe to the Feed
          </a>
        </li>
      </ul>
    </section>

    <section id="popular">
      <h1>Popular Posts</h1>
      <ul>
      
        <li><a href="/2012/06/05/whats-it-like-to-work-at-github/">What's it like to work at GitHub?</a></li>
      
        <li><a href="/2012/05/23/why-our-code-smells/">Why Our Code Smells</a></li>
      
        <li><a href="/2012/01/12/getting-started-with-sublime-text-2/">Getting Started with Sublime Text 2</a></li>
      
        <li><a href="/2012/01/09/the-40-standup-desk/">The $40 Standup Desk</a></li>
      
        <li><a href="/2011/11/30/haml-the-unforgivable-sin/">HAML: the unforgivable sin</a></li>
      
      </ul>
    </section>

  </div>

  <footer id="copyright">
    Copyright © 2006 - 2013 Brandon Keepers
  </footer>
</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-817617-1");
pageTracker._trackPageview();
} catch(err) {}
</script>

<script type="text/javascript">
  (function() {
    var t = document.createElement('script');
    t.type = 'text/javascript'; t.async = true;
    t.id = 'gauges-tracker'; t.setAttribute('data-site-id', '4d5c434255da1271e4000002');
    t.src = 'http://gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
</body>
</html>
