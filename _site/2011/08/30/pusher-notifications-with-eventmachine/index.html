<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pusher notifications with EventMachine</title>
  <meta name="description" content="a blog about code">
  <meta name="author" content="Brandon Keepers">
  <meta name="verify-v1" content="UwU5mecrHiDTPVlphLl729aaRCmyz93jrs+ER3RP4Pw=">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google-site-verification" content="h4QNmQOrsvnIEsMH5GS3s4_jV3ZAZgrEoZdL4RsbOMI" />

  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" href="/assets/site-384b0ce11bd2b42c9eff7cec3faccf76.css">

  <link rel="openid.server" href="http://www.myopenid.com/server">
  <link rel="openid.delegate" href="http://bkeepers.myopenid.com/">
  <link href="http://feeds.feedburner.com/opensoul" rel="alternate" title="opensoul.org" type="application/atom+xml">

  <!-- FIXME:  -->
</head>
<body>
<div class="container">
  <header>
    <h1><a href="/">opensoul.org</a></h1>
  </header>

  <div id="content">
    <article>
  <h1 class="small">Pusher notifications with EventMachine</h1>
  <p class="meta">
    <span class="date">August 30, 2011</span>
    <span class="tags">
      
        em,
      
        gauges,
      
        pusher,
      
        redis
      
    </span>
  </p>
  <div class="body"><p><a href="http://gaug.es">Gaug.es</a> has been a fun exercise in building an app to scale from the start.  <a href="http://railstips.org/blog/archives/2011/05/04/eventmachine-and-passenger/">John Nunemaker previously posted about our quest</a> to send live updates to the browser without slowing down the request cycle.</p>
<h2>Backstory</h2>
<p>We use <a href="http://pusher.com/">Pusher</a> to send realtime updates of stats to the Gaug.es dashboard. We started out on Heroku–which uses Thin, which runs on EventMachine–so we could just use EventMachine and Pusher&#8217;s <code>trigger_async</code> method to queue the Pusher update on the next tick, thus not affecting response times. But then we moved from Heroku to <a href="http://railsmachine.com/">RailsMachine</a> and their Passenger stack, so we wanted to find a way to keep the Pusher update out of the request cycle but still &#8220;realtime&#8221;.</p>
<p>So John devised a genius plan of starting up a thread in Passenger that runs EventMachine. We can still use the <code>trigger_async</code> method and take advantage of EventMachine&#8217;s IO goodness, and only suffer hits in response time occasionally when Ruby&#8217;s naive thread scheduling interrupts the passenger process in the middle of a request.</p>
<h2>It <del>didn&#8217;t</del> <ins>did</ins> work</h2>
<p>This ran great in production for a few weeks. But as our traffic started to increase thanks to launching several new features, we started to run into problems. Passenger processes frequently started hanging and gobbling up ungodly amounts of <span class="caps">CPU</span>. The only way to recover was to snipe the processes with the friendly <code>kill -9</code>.</p>
<p>So we tried to concoct a theory: since most of our hits are ridiculously fast (5-10ms), and we were running multiple threads but weren&#8217;t doing anything fancy to set priority or control scheduling, the passenger thread must be handling requests faster than the EventMachine thread can send them to Pusher, causing the Event Machine thread to get backed up to the point where it has so many IO connections open that it thrashes the <span class="caps">CPU</span>.</p>
<p>It turns out our theory was wrong (we were actually hitting a <a href="https://gist.github.com/1079284">crazy bug with the regex engine in all major versions of Ruby</a>), but we didn&#8217;t know that at the time. So we concluded that we had to take the Pusher notification out of the request cycle.</p>
<h2>Redis and EventMachine to the rescue</h2>
<p>With help from <a href="http://twitter.com/gaffneyc">Chris Gaffney</a>, I came up with a different approach that pushes hits on a Redis list and uses a separate EventMachine process to send them to Pusher.</p>
<p>In our Sinatra application, we just push <span class="caps">JSON</span> from the notification onto a list.</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Gauges</span><span class="o">.</span><span class="n">redis</span><span class="o">.</span><span class="n">rpush</span><span class="p">(</span><span class="s1">&#39;notifications&#39;</span><span class="p">,</span> <span class="n">notification</span><span class="o">.</span><span class="n">to_json</span><span class="p">)</span>
</code></pre></div><p>Redis list operations are fast, even with a decent-sized blob of text. Now our app doesn&#8217;t have to worry about the overhead of sending the notifications.</p>
<p>Next we needed background process to process the Redis list and communicate with Pusher. EventMachine is well-suited for all of this IO, so we wrote this simple script:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">module</span> <span class="nn">Gauges</span>
  <span class="k">module</span> <span class="nn">Pusher</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">redis</span>
      <span class="vi">@redis</span> <span class="o">||=</span> <span class="no">EM</span><span class="o">::</span><span class="no">Hiredis</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;redis://localhost:6379&quot;</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">next</span>
      <span class="n">redis</span><span class="o">.</span><span class="n">blpop</span><span class="p">(</span><span class="s1">&#39;notifications&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">callback</span> <span class="k">do</span> <span class="o">|</span><span class="n">list</span><span class="p">,</span> <span class="n">data</span><span class="o">|</span>
        <span class="n">notification</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">notification</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">&#39;channel&#39;</span><span class="p">)</span>
        <span class="o">::</span><span class="no">Pusher</span><span class="o">[</span><span class="n">channel</span><span class="o">].</span><span class="n">trigger_async</span><span class="p">(</span><span class="s1">&#39;hit&#39;</span><span class="p">,</span> <span class="n">notification</span><span class="p">)</span>
        <span class="no">EM</span><span class="o">.</span><span class="n">next_tick</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:next</span><span class="p">))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">EM</span><span class="o">.</span><span class="n">run</span> <span class="k">do</span>
  <span class="no">Gauges</span><span class="o">::</span><span class="no">Pusher</span><span class="o">.</span><span class="n">next</span>
<span class="k">end</span>
</code></pre></div><p>It uses em-hiredis to connect to Redis and run a blocking left pop, which will wait until there is an item on the list and then send the notification to Pusher with <code>trigger_async</code>. It then re-schedules itself to run on the next tick, causing it to continuously loop.</p>
<p>This has been working really well for us in production for a couple months now. The biggest disadvantage currently is if the process ever dies and notifications start to build up, Pusher will get inundated with requests form us because it will send them as fast as Redis can pop them off the list. We will eventually look into adding some rate-limiting.</p></div>

  <div id="be-social">
    <a href="https://twitter.com/share" class="twitter-share-button" data-via="bkeepers" data-lang="en" data-related="bkeepers">Tweet</a>
    <a href="https://twitter.com/bkeepers" class="twitter-follow-button" data-show-count="false" data-lang="en">Follow @bkeepers</a>
  </div>
</article>

  </div>

  <div id="about">
    <section>
      <p>I am <strong>Brandon Keepers</strong>. I build Internet things, usually with Ruby or JavaScript. I work at <a href="http://github.com">GitHub</a> and live in Holland, MI.</p>

      <ul id="links">
        <li>
          <a href="http://twitter.com/bkeepers">
            <span class="icon icon-mark-twitter"></span>
            Follow me on Twitter
          </a>
        </li>
        <li>
          <a href="http://github.com/bkeepers">
            <span class="icon icon-mark-github"></span>
            Follow me on GitHub
          </a>
        </li>
        <li>
          <a href="http://feeds.feedburner.com/opensoul">
            <span class="icon icon-feed"></span>
            Subscribe to the Feed
          </a>
        </li>
      </ul>
    </section>

    <section id="popular">
      <h1>Popular Posts</h1>
      <ul>
      
        <li><a href="/2012/06/05/whats-it-like-to-work-at-github/">What's it like to work at GitHub?</a></li>
      
        <li><a href="/2012/05/23/why-our-code-smells/">Why Our Code Smells</a></li>
      
        <li><a href="/2012/01/12/getting-started-with-sublime-text-2/">Getting Started with Sublime Text 2</a></li>
      
        <li><a href="/2012/01/09/the-40-standup-desk/">The $40 Standup Desk</a></li>
      
        <li><a href="/2011/11/30/haml-the-unforgivable-sin/">HAML: the unforgivable sin</a></li>
      
      </ul>
    </section>

  </div>

  <footer id="copyright">
    Copyright © 2006 - 2013 Brandon Keepers
  </footer>
</div>

<!--
FIXME:

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-817617-1");
pageTracker._trackPageview();
} catch(err) {}
</script>

<script type="text/javascript">
  (function() {
    var t = document.createElement('script');
    t.type = 'text/javascript'; t.async = true;
    t.id = 'gauges-tracker'; t.setAttribute('data-site-id', '4d5c434255da1271e4000002');
    t.src = 'http://gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
-->
</body>
</html>
