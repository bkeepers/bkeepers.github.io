---
layout: post
title: "RSpec is getting too intimate with my code"
id: 4cf5b66fdabe9d2c61000371
updated: 2010-11-30T21:43:59-05:00
date: 2007-06-20T03:56:00-04:00
categories:
- rails
- rspec
- ruby
- testing
excerpt: ""
---

The theory is that tests are supposed to be agnostic of the implementation. This leads to less brittle tests and actually tests the outcome (or behavior).

With RSpec, I feel like the common approach of completely mocking your models to test your controllers ends up forcing you to look too much into the implementation of your controller.

Here is an example of a spec that is generated by the rspec_scaffold generator:

{% highlight ruby %}
describe ThingsController, "handling POST /things" do

  before do
    @params = {}
    @thing = mock_model(Thing, :to_param => "1", :save => true)
    Thing.stub!(:new).and_return(@thing)
  end

  def do_post
    post :create, :thing => @params
  end

  it "should create a new thing" do
    Thing.should_receive(:new).with(@params).and_return(@thing)
    do_post
  end

  it "should redirect to the new thing" do
    do_post
    response.should redirect_to(@thing)
  end
end
{% endhighlight %}

This by itself is not too bad, but the problem is that it peers too much into the controller to dictate how the model is used.  Why does it matter if my controller calls @Thing.new@?  What if my controller decides to take the @Thing.create!@ and @rescue@ route? What if my model has a special initializer method, like @Thing.build_with_foo@? My spec for _behavior_ should not fail if I change the implementation.

This problem gets even worse when you have nested resources and are creating multiple models per controller.  Some of my setup methods end up being 15 or more lines long and VERY fragile.

RSpec's intention is to completely isolate your controller logic from your models, which sounds good in theory, but almost runs against the grain for an integrated stack like Rails. Especially if you practice the skinny controller/fat model discipline, the amount of logic in the controller becomes very small, and the setup becomes huge.

So what's a BDD-wannabe to do?  Taking a step back, the _behavior_ that I really want to test is not that my controller calls @Thing.new@, but that given parameters _X_, it creates a new thing and redirects to it.

Here's the approach I've been taking:

{% highlight ruby %}
# spec_helper.rb
def valid_thing_attrs(attrs = {})
  {:name => 'Foo'}.merge(attrs)
end

# things_controller_spec.rb
describe ThingsController, "handling POST /things" do

  def do_post
    post :create, :thing => valid_thing_attrs
  end

  it "should create a new thing" do
    lambda { do_post }.should change { Thing.count }.by(1)
  end

  it "should redirect to the new thing" do
    do_post
    response.should redirect_to(@thing)
  end
end
{% endhighlight %}

My spec is now testing that posting certain attributes creates a new thing (in the database) and redirects to it. You'll notice that I have a method called @valid_thing_attrs@.  I don't remember where I picked up this pattern, but it is something that has allowed me to minimize all of my test's dependencies on the model.

My spec is now somewhat dependent on my model–and thus will break if my model gets hosed–but that is a small price to pay, in my opinion, for an implementation-agnostic spec with significantly less overhead.

What do you think?
